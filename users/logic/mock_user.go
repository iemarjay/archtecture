// Code generated by MockGen. DO NOT EDIT.
// Source: orchestrator.go

// Package logic is a generated GoMock package.
package logic

import (
	events "archtecture/app/events"
	notification "archtecture/app/notification"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockuserRepository is a mock of userRepository interface.
type MockuserRepository struct {
	ctrl     *gomock.Controller
	recorder *MockuserRepositoryMockRecorder
}

// MockuserRepositoryMockRecorder is the mock recorder for MockuserRepository.
type MockuserRepositoryMockRecorder struct {
	mock *MockuserRepository
}

// NewMockuserRepository creates a new mock instance.
func NewMockuserRepository(ctrl *gomock.Controller) *MockuserRepository {
	mock := &MockuserRepository{ctrl: ctrl}
	mock.recorder = &MockuserRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockuserRepository) EXPECT() *MockuserRepositoryMockRecorder {
	return m.recorder
}

// EmailOrPhoneExists mocks base method.
func (m *MockuserRepository) EmailOrPhoneExists(arg0, arg1 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EmailOrPhoneExists", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EmailOrPhoneExists indicates an expected call of EmailOrPhoneExists.
func (mr *MockuserRepositoryMockRecorder) EmailOrPhoneExists(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EmailOrPhoneExists", reflect.TypeOf((*MockuserRepository)(nil).EmailOrPhoneExists), arg0, arg1)
}

// StoreUser mocks base method.
func (m *MockuserRepository) StoreUser(arg0 *UserData) (*UserData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreUser", arg0)
	ret0, _ := ret[0].(*UserData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// StoreUser indicates an expected call of StoreUser.
func (mr *MockuserRepositoryMockRecorder) StoreUser(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreUser", reflect.TypeOf((*MockuserRepository)(nil).StoreUser), arg0)
}

// Mocknotifier is a mock of notifier interface.
type Mocknotifier struct {
	ctrl     *gomock.Controller
	recorder *MocknotifierMockRecorder
}

// MocknotifierMockRecorder is the mock recorder for Mocknotifier.
type MocknotifierMockRecorder struct {
	mock *Mocknotifier
}

// NewMocknotifier creates a new mock instance.
func NewMocknotifier(ctrl *gomock.Controller) *Mocknotifier {
	mock := &Mocknotifier{ctrl: ctrl}
	mock.recorder = &MocknotifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mocknotifier) EXPECT() *MocknotifierMockRecorder {
	return m.recorder
}

// Notify mocks base method.
func (m *Mocknotifier) Notify(arg0 notification.Notifiable) notification.Notifier {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Notify", arg0)
	ret0, _ := ret[0].(notification.Notifier)
	return ret0
}

// Notify indicates an expected call of Notify.
func (mr *MocknotifierMockRecorder) Notify(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Notify", reflect.TypeOf((*Mocknotifier)(nil).Notify), arg0)
}

// That mocks base method.
func (m *Mocknotifier) That(arg0 notification.Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "That", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// That indicates an expected call of That.
func (mr *MocknotifierMockRecorder) That(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "That", reflect.TypeOf((*Mocknotifier)(nil).That), arg0)
}

// Mockevent is a mock of event interface.
type Mockevent struct {
	ctrl     *gomock.Controller
	recorder *MockeventMockRecorder
}

// MockeventMockRecorder is the mock recorder for Mockevent.
type MockeventMockRecorder struct {
	mock *Mockevent
}

// NewMockevent creates a new mock instance.
func NewMockevent(ctrl *gomock.Controller) *Mockevent {
	mock := &Mockevent{ctrl: ctrl}
	mock.recorder = &MockeventMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockevent) EXPECT() *MockeventMockRecorder {
	return m.recorder
}

// Emit mocks base method.
func (m *Mockevent) Emit(arg0 events.Name, arg1 interface{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Emit", arg0, arg1)
}

// Emit indicates an expected call of Emit.
func (mr *MockeventMockRecorder) Emit(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Emit", reflect.TypeOf((*Mockevent)(nil).Emit), arg0, arg1)
}
